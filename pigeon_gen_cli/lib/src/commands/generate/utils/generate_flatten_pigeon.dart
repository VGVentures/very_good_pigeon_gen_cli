import 'dart:io';

import 'package:analyzer/dart/analysis/utilities.dart';
import 'package:analyzer/dart/ast/ast.dart';
import 'package:analyzer/dart/ast/visitor.dart';

/// Generates a flattened pigeon file containing all used class definitions.
/// - [pigeonFileContent] → content of the pigeon file only with pigeon import
/// - [classToFile] → map from class name to the file where it’s defined
/// - [targetFilePath] → path of the generated flattened Dart file
Future<void> generateFlattenedPigeonFile(
  String pigeonFileContent,
  Map<String, String> classToFile,
  String targetFilePath,
) async {
  final visitedClasses = <String>{};
  final buffer = StringBuffer();

  // Sort classes to maintain dependency order (roughly)
  for (final className in classToFile.keys) {
    await _appendClassRecursively(
      className,
      classToFile,
      visitedClasses,
      buffer,
    );
  }

  // Write to file
  final file = File(targetFilePath);

  /// Add auto-generated header at the top of the content to import
  final header = StringBuffer()
    ..writeln('// Auto-generated by pigeon_gen_cli')
    ..writeln('// DO NOT EDIT')
    ..writeln('// Generated on ${DateTime.now().toIso8601String()}')
    ..writeln();

  final fullContent = StringBuffer()
    ..write(header.toString())
    ..write(pigeonFileContent)
    ..write(buffer.toString());

  final fullContentString = removeLastLine(fullContent.toString());

  await file.writeAsString(fullContentString);
}

/// Recursively append a class and its dependent classes
Future<void> _appendClassRecursively(
  String className,
  Map<String, String> classToFile,
  Set<String> visitedClasses,
  StringBuffer buffer,
) async {
  if (visitedClasses.contains(className)) return;
  visitedClasses.add(className);

  final filePath = classToFile[className];
  if (filePath == null) return;

  final source = await File(filePath).readAsString();
  final unit = parseString(content: source, path: filePath).unit;

  // Find all class and enum declarations in the file
  for (final decl
      in unit.declarations.whereType<NamedCompilationUnitMember>()) {
    final name = decl.name.lexeme;

    // Only process the class we want
    if (name != className) continue;

    // Find referenced classes inside this class to handle dependencies
    final referencedClasses = <String>{};
    decl.visitChildren(TypeReferenceCollector(referencedClasses));

    // Recursively append dependencies first
    for (final ref in referencedClasses) {
      await _appendClassRecursively(ref, classToFile, visitedClasses, buffer);
    }

    // Extract the full source code of this class
    final classSource = source.substring(decl.offset, decl.end);
    buffer
      ..writeln(classSource)
      ..writeln();
  }
}

/// Collects type identifiers from AST nodes
class TypeReferenceCollector extends RecursiveAstVisitor<void> {
  TypeReferenceCollector(this.references);

  final Set<String> references;

  @override
  void visitNamedType(NamedType node) {
    references.add(node.name2.lexeme);
    super.visitNamedType(node);
  }
}

String removeLastLine(String input) {
  final lines = input.split('\n');
  if (lines.isEmpty) return input;
  lines.removeLast();
  return lines.join('\n');
}
